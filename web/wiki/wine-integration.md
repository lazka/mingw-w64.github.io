# Wine integration

## Wine integration

mingw-w64 has a lot in common with
<a href="http://www.winehq.org" rel="nofollow">The Wine</a> project. The
idea is to share as much code as possible to avoid work duplication.
This pages describes ideas, status and TODOs for co-operation between
mingw-w64 and Wine.

### WIDL

widl is Wine reimplementation of MIDL, Microsoft IDL compiler.

-   Needs to be imported to mingw-w64 SVN and added to build system.
-   Licensing worries: WIDL is LGPL-ed and its produced code must not
    enforce any licensing limits. Current understanding is that
    autogenerated code inherits IDL license. There are some code chunks
    in generated code that are not autogenerated, so they imply LGPL
    license. Alexandre Julliard (their author) agreed to relicense them.
    They could be also avoided by using compiler exceptions.

### Headers

mingw-w64 requires the same headers set as Wine does. In theory, we
could use almost the same headers.

-   Review is needed to decide which headers and how should be merged
-   A semi-automated way is needed for merges

> > Initial script committed to experimental tree wine/wine-import.sh

-   winetest can be used to validate merges
-   Wine build system needs to support using external header set. See
    bellow.
-   mingw-w64 must be able to compile tests. It involves both fixes to
    headers and Wine (that are rarely tested against non-wine headers)
-   Wine uses WINELIB\_NAME\_AW macros, mingw-w64 MINGW\_NAME\_AW.
    Ideally we should have compatible names.
-   Wine can't use L"..." for UNICODE strings. This implies
    complications in string definitions. An automated way for changing
    them is required (magic comments?))

### IDL files

-   Wine IDL files are LGPL-ed, which may imply LGPL typelibs and
    proxy/stubs. Temporary solution: not include IDL files in base
    product, provide them in an optional SDK. Long term solution:
    probably needs lawyer consultation.

### importlibs

-   Investigate if Wine's .spec files will be useful for mingw-w64.

### msvcrt

-   Needs investigation

### libs like uuid

-   Low priority

### Compiling Wine tests

Wine has its test suite. Although it's primary aimed to test Windows
behavior, not header files, it makes extensive use of header files, so
it's a good candidate for testing them. In typical configuration, Wine
uses its own headers. Using this <a
href="http://www.winehq.org/pipermail/wine-patches/2010-June/089444.html"
rel="nofollow">patch</a> (waiting for the end of code freeze for
inclusion) it's possible to compile Wine tests with mingw-w64 headers.
Here are steps how to do that:

-   Get Wine source (from SourceForge? or git)

-   Apply mentioned patch:

        $ wget http://www.winehq.org/pipermail/wine-patches/attachments/20100610/8024ea7e/attachment.bin
        $ patch -p1 <attachment.bin

-   Make a special directory that will replace Wine's include directory:

        $ mkdir $HOME/mingw-w64/wine-include
        $ ln -s $HOME/wine/include/wine $HOME/mingw-w64/include/wine

-   Configure Wine (to test on x86, ignore --enable-win64 argument):

        $ CROSSINCLUDES=-I/home/jacek/mingw-w64/wine-include/ ./configure --enable-win64

-   Compile Wine (FIXME: complete compilation is not needed, investigate
    smarter way):

        $ make

Now you can compile tests. Ideally, make crosstest should do the trick,
but we are far from there yet. The easiest way is compile one file at
the time. Tests are organized in files dlls/dll\_name/tests/test\_name.c
and eg. make dlls/mshtml/tests/misc.cross.o will compile misc tests of
mshtml.dll.

#### tricks

To get a list of successes/failures, run script:

    echo >good
    echo >bad

    for f in $(ls */*/tests/*.c |sed 's/\.c//'); do
        rm -f $f.cross.o
        if make $f.cross.o; then
            echo $f >>good
        else
            echo $f >>bad
        fi
    done

It will create two files: good and bad that contain tests that succeeded
and failed. Now if you want to verify that there was no regression, you
can run:

    $ for f in $(cat good); do make $f.cross.o; done

if you're looking for failures to fix, run:

    $ for f in $(cat bad); do make $f.cross.o; done